
name: Fan-out labels to repositories

on:
  workflow_dispatch:
    inputs:
      strict:
        description: "Delete labels not defined"
        required: false
        default: false
        type: boolean
      dry-run:
        description: "Preview only"
        required: false
        default: false
        type: boolean
      ref:
        description: "Branch/tag in .github to read labels from"
        required: false
        default: main
        type: string

  push:
    branches: [ develop, main ]
    paths: [ "labels/labels.yml", "repos.txt" ]

permissions:
  contents: read

jobs:
  plan:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      labels-ref: ${{ steps.set-ref.outputs.ref }}
    steps:
      - uses: actions/checkout@v4

      - id: set-ref
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.ref }}" ]; then
            echo "ref=${{ inputs.ref }}" >> "$GITHUB_OUTPUT"
          else
            echo "ref=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"
          fi

      - id: set-matrix
        shell: bash
        run: |
          repos=$(grep -v '^\s*$' repos.txt | grep -v '^#' | jq -R . | jq -c -s .)
          echo "matrix={\"repo\":$repos}" >> "$GITHUB_OUTPUT"

  apply:
    needs: plan
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.plan.outputs.matrix) }}
    steps:
      - name: Checkout org .github (labels source)
        uses: actions/checkout@v4
        with:
          repository: winccoa-tools-pack/.github
          ref: ${{ needs.plan.outputs.labels-ref }}
          path: org-dot-github

      - name: Dry run plan for ${{ matrix.repo }}
        if: ${{ inputs.dry-run }}
        run: |
          echo "Dry run enabled. Would apply labels from labels/labels.yml to: ${{ matrix.repo }}"
          echo "strict=${{ inputs.strict }}"
          cat org-dot-github/labels/labels.yml

      - name: Apply labels via GitHub API (Python)
        if: ${{ !inputs.dry-run }}
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_LABELS_PAT }}
          TARGET_REPO: ${{ matrix.repo }}
          STRICT: ${{ inputs.strict }}
        run: |
          python3 - << 'PY'
          import os, sys
          import requests
          try:
              import yaml
          except Exception:
              import subprocess
              subprocess.check_call([sys.executable, "-m", "pip", "install", "pyyaml"])
              import yaml

          GITHUB_TOKEN = os.environ["GITHUB_TOKEN"]
          TARGET_REPO = os.environ["TARGET_REPO"]
          STRICT = os.environ.get("STRICT","false").lower() == "true"

          headers = {
              "Authorization": f"Bearer {GITHUB_TOKEN}",
              "Accept": "application/vnd.github+json"
          }

          def norm_color(c):
              if c is None: return "ffffff"
              if isinstance(c, int): return f"{c:06x}"
              s = str(c).strip().lower()
              if s.startswith("#"): s = s[1:]
              s = (s + "000000")[:6]
              try: int(s, 16)
              except ValueError: s = "ffffff"
              return s

          with open("org-dot-github/labels/labels.yml", "r", encoding="utf-8") as f:
              desired = yaml.safe_load(f) or []

          desired_by_name = {d["name"]: d for d in desired}

          base = f"https://api.github.com/repos/{TARGET_REPO}/labels"

          # Current labels
          current = []
          page = 1
          while True:
              r = requests.get(base, headers=headers, params={"per_page":100, "page":page})
              r.raise_for_status()
              batch = r.json()
              if not batch: break
              current.extend(batch)
              page += 1

          current_by_name = {l["name"]: l for l in current}
          failures = []

          # Upsert desired
          for item in desired:
              name = item["name"]
              color = norm_color(item.get("color"))
              desc = (item.get("description") or "").strip()
              if name in current_by_name:
                  url = f"{base}/{requests.utils.quote(name, safe='')}"
                  payload = {"name": name, "color": color, "description": desc}
                  resp = requests.patch(url, headers=headers, json=payload)
                  if resp.status_code != 200:
                      failures.append(f"Update {name}: {resp.status_code} {resp.text}")
                      print(f"Failed to update {name}: {resp.status_code} {resp.text}", file=sys.stderr)
                  else:
                      print(f"Updated: {name}")
              else:
                  payload = {"name": name, "color": color, "description": desc}
                  resp = requests.post(base, headers=headers, json=payload)
                  if resp.status_code != 201:
                      failures.append(f"Create {name}: {resp.status_code} {resp.text}")
                      print(f"Failed to create {name}: {resp.status_code} {resp.text}", file=sys.stderr)
                  else:
                      print(f"Created: {name}")

          # Strict delete
          if STRICT:
              for name in list(current_by_name.keys()):
                  if name not in desired_by_name:
                      url = f"{base}/{requests.utils.quote(name, safe='')}"
                      resp = requests.delete(url, headers=headers)
                      if resp.status_code != 204:
                          failures.append(f"Delete {name}: {resp.status_code} {resp.text}")
                          print(f"Failed to delete {name}: {resp.status_code} {resp.text}", file=sys.stderr)
                      else:
                          print(f"Deleted (strict): {name}")

          if failures:
              print("One or more label operations failed:")
              for f in failures: print("  -", f)
              sys.exit(1)

          print("Done.")
          PY
